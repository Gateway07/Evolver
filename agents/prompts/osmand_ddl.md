CREATE SCHEMA IF NOT EXISTS osmand;

-- Original city data
CREATE TABLE osmand.city (
  id   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  lat  DOUBLE PRECISION NOT NULL,
  lon  DOUBLE PRECISION NOT NULL,
  name VARCHAR(255) NOT NULL,
  state CHAR(2),
  country VARCHAR(128) DEFAULT 'USA'
);

-- Original streets data
CREATE TABLE osmand.street (
  id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  lat     DOUBLE PRECISION NOT NULL,
  lon     DOUBLE PRECISION NOT NULL,
  name    VARCHAR(255) NOT NULL,
  city_id BIGINT NOT NULL REFERENCES osmand.city(id) ON DELETE RESTRICT
);
CREATE INDEX street_city_id_idx ON osmand.street(city_id);

-- Original houses data
CREATE TABLE osmand.house (
  id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name      VARCHAR(255) NOT NULL,
  street_id BIGINT NOT NULL REFERENCES osmand.street(id) ON DELETE RESTRICT,
  lat       DOUBLE PRECISION NOT NULL,
  lon       DOUBLE PRECISION NOT NULL
);
CREATE INDEX house_street_id_idx ON osmand.house(street_id);

-- Words (geo/region, common terms) are excluded from OSMAND index
CREATE TABLE osmand.stop_word (
    name VARCHAR(64) as primary key,
    seq INT
);


-- Test experiment runs
CREATE TABLE osmand.run (
    id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    query_sql     TEXT,
    locale        VARCHAR(64),
    status        VARCHAR(64) NOT NULL CHECK (status IN ('RUNNING', 'COMPLETED', 'FAILED')),
    run_error     TEXT,
    run_start     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    run_finish    TIMESTAMP,
    threads_count INT,
    -- Objective is not_found = total_count - found_count - failed_count - partial_found_count, MAX(not_found / found_count) and MAX(search_duration_ms / total_duration_ms)
    total_count   INT, 
    failed_count  INT, 
    found_count   INT, 
    partial_found_count INT, 
    total_duration_ms BIGINT, 
    total_bytes   BIGINT,
    search_duration_ms BIGINT
);

-- Test results after experiments
CREATE TABLE osmand.run_result (
    id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    run_id         BIGINT NOT NULL REFERENCES osmand.run(id) ON DELETE CASCADE,
    city_id        BIGINT NOT NULL REFERENCES osmand.city(id) ON DELETE RESTRICT,
    street_id      BIGINT NOT NULL REFERENCES osmand.street(id) ON DELETE RESTRICT,
    house_id       BIGINT NOT NULL REFERENCES osmand.house(id) ON DELETE RESTRICT,
    lat            DOUBLE PRECISION NOT NULL,
    lon            DOUBLE PRECISION NOT NULL,
    address        VARCHAR(255),
    res_error      VARCHAR(1024),
    res_duration   INT,
    res_timestamp  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    res_place      INT,
    res_lat        DOUBLE PRECISION,
    res_lon        DOUBLE PRECISION,
    res_distance   INT,
    res_count      INT,
    res_found      BOOLEAN,
    res_stat_bytes INT,
    res_stat_time  BIGINT
);

-- Indexes for performance
CREATE INDEX idx_run_result_run_id ON osmand.run_result(run_id);
CREATE INDEX idx_run_result_city_id ON osmand.run_result(city_id);
CREATE INDEX idx_run_result_street_id ON osmand.run_result(street_id);
CREATE INDEX idx_run_result_house_id ON osmand.run_result(house_id);

CREATE MATERIALIZED VIEW osmand.address AS
SELECT 
    ROW_NUMBER() OVER (ORDER BY c.id, s.id, h.id) AS id,
    h.lat AS lat,
    h.lon AS lon,
    h.id AS house_id,
    h.name AS house_name,
    s.id AS street_id,
    s.name AS street_name,
    c.id AS city_id,
    c.name AS city_name,
    h.name || ' ' || s.name || ' ' || c.name AS address
FROM osmand.house h
JOIN osmand.street s ON h.street_id = s.id
JOIN osmand.city c ON s.city_id = c.id
WITH DATA;

-- Refresh concurrently (requires unique index)
CREATE UNIQUE INDEX CONCURRENTLY address_house_id_idx ON osmand.address(city_id, street_id, house_id);
REFRESH MATERIALIZED VIEW CONCURRENTLY osmand.address;