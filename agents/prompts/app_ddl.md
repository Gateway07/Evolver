CREATE SCHEMA IF NOT EXISTS app;

-- Original city data
CREATE TABLE app.city (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
lat DOUBLE PRECISION NOT NULL,
lon DOUBLE PRECISION NOT NULL,
name VARCHAR(255) NOT NULL,
state CHAR(2),
country VARCHAR(128) DEFAULT 'USA'
);

-- Original streets data
CREATE TABLE app.street (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
lat DOUBLE PRECISION NOT NULL,
lon DOUBLE PRECISION NOT NULL,
name VARCHAR(255) NOT NULL,
city_id BIGINT NOT NULL REFERENCES app.city(id) ON DELETE RESTRICT
);
CREATE INDEX street_city_id_idx ON app.street(city_id);

-- Original houses data
CREATE TABLE app.house (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
name VARCHAR(255) NOT NULL,
street_id BIGINT NOT NULL REFERENCES app.street(id) ON DELETE RESTRICT,
lat DOUBLE PRECISION NOT NULL,
lon DOUBLE PRECISION NOT NULL
);
CREATE INDEX house_street_id_idx ON app.house(street_id);

-- Words (geo/region, common terms) are excluded from OSMAND index
CREATE TABLE app.stop_word (
name VARCHAR(64) as primary key,
seq INT
);

-- Test experiment runs
CREATE TABLE app.run (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
query_sql TEXT,
locale VARCHAR(64),
status VARCHAR(64) NOT NULL CHECK (status IN ('RUNNING', 'COMPLETED', 'FAILED')),
run_error TEXT,
run_start TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
run_finish TIMESTAMP,
threads_count INT,
-- Objective is not_found = total_count - found_count - failed_count - partial_found_count, MAX(not_found / found_count)
and MAX(search_duration_ms / total_duration_ms)
total_count INT,
failed_count INT,
found_count INT,
partial_found_count INT,
total_duration_ms BIGINT,
total_bytes BIGINT,
search_duration_ms BIGINT
);

-- Test results after experiments
CREATE TABLE app.run_result (
id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
run_id BIGINT NOT NULL REFERENCES app.run(id) ON DELETE CASCADE,
city_id BIGINT NOT NULL REFERENCES app.city(id) ON DELETE RESTRICT,
street_id BIGINT NOT NULL REFERENCES app.street(id) ON DELETE RESTRICT,
house_id BIGINT NOT NULL REFERENCES app.house(id) ON DELETE RESTRICT,
lat DOUBLE PRECISION NOT NULL,
lon DOUBLE PRECISION NOT NULL,
address VARCHAR(255),
res_error VARCHAR(1024),
res_duration INT,
res_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
res_place INT,
res_lat DOUBLE PRECISION,
res_lon DOUBLE PRECISION,
res_distance INT,
res_count INT,
res_found BOOLEAN,
res_stat_bytes INT,
res_stat_time BIGINT
);

-- Indexes for performance
CREATE INDEX idx_run_result_run_id ON app.run_result(run_id);
CREATE INDEX idx_run_result_city_id ON app.run_result(city_id);
CREATE INDEX idx_run_result_street_id ON app.run_result(street_id);
CREATE INDEX idx_run_result_house_id ON app.run_result(house_id);

CREATE MATERIALIZED VIEW app.address AS
SELECT
ROW_NUMBER() OVER (ORDER BY c.id, s.id, h.id) AS id,
h.lat AS lat,
h.lon AS lon,
h.id AS house_id,
h.name AS house_name,
s.id AS street_id,
s.name AS street_name,
c.id AS city_id,
c.name AS city_name,
h.name || ' ' || s.name || ' ' || c.name AS address
FROM app.house h
JOIN app.street s ON h.street_id = s.id
JOIN app.city c ON s.city_id = c.id
WITH DATA;

-- Refresh concurrently (requires unique index)
CREATE UNIQUE INDEX CONCURRENTLY address_house_id_idx ON app.address(city_id, street_id, house_id);
REFRESH MATERIALIZED VIEW CONCURRENTLY app.address;

CREATE TABLE "theory"."surrogate_feature" (
"id" int8 NOT NULL DEFAULT nextval('"theory".surrogate_feature_id_seq'::regclass),
"name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
"schema" varchar(255) COLLATE "pg_catalog"."default",
"signature" varchar(255) COLLATE "pg_catalog"."default",
"version" int2,
"object" varchar(255) COLLATE "pg_catalog"."default",
"source" varchar(255) COLLATE "pg_catalog"."default",
CONSTRAINT "surrogate_feature_pkey" PRIMARY KEY ("id")
)
;

-- ----------------------------
-- Sequence structure for surrogate_feature_id_seq
-- ----------------------------
DROP SEQUENCE IF EXISTS "theory"."surrogate_feature_id_seq";
CREATE SEQUENCE "theory"."surrogate_feature_id_seq"
INCREMENT 1
MINVALUE 1
MAXVALUE 9223372036854775807
START 1
CACHE 1;

-- ----------------------------
-- Table structure for surrogate_feature
-- ----------------------------
DROP TABLE IF EXISTS "theory"."surrogate_feature";
CREATE TABLE "theory"."surrogate_feature" (
"id" int8 NOT NULL DEFAULT nextval('"theory".surrogate_feature_id_seq'::regclass),
"name" varchar(255) COLLATE "pg_catalog"."default" NOT NULL,
"schema" varchar(255) COLLATE "pg_catalog"."default",
"signature" varchar(255) COLLATE "pg_catalog"."default",
"version" int2,
"object" varchar(255) COLLATE "pg_catalog"."default",
"source" varchar(255) COLLATE "pg_catalog"."default"
)
;
COMMENT ON COLUMN "theory"."surrogate_feature"."name" IS 'feature name';
COMMENT ON COLUMN "theory"."surrogate_feature"."object" IS 'table/view';
COMMENT ON COLUMN "theory"."surrogate_feature"."source" IS 'field';

-- ----------------------------
-- Alter sequences owned by
-- ----------------------------
ALTER SEQUENCE "theory"."surrogate_feature_id_seq"
OWNED BY "theory"."surrogate_feature"."id";
SELECT setval('"theory"."surrogate_feature_id_seq"', 1, false);

-- ----------------------------
-- Primary Key structure for table surrogate_feature
-- ----------------------------
ALTER TABLE "theory"."surrogate_feature" ADD CONSTRAINT "surrogate_feature_pkey" PRIMARY KEY ("id");

-- ----------------------------
-- View structure for street_tail_min_df
-- ----------------------------
DROP VIEW IF EXISTS "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."street_tail_min_df";
CREATE VIEW "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."street_tail_min_df" AS SELECT sp.id,
min(d.df) AS min_tail_df
FROM "theory$prefix4_head_tail_df$ab12cd34ef56$v0".street_p4 sp
JOIN "theory$prefix4_head_tail_df$ab12cd34ef56$v0".p4_df d ON d.p4 = sp.p4
WHERE sp.pos > 1
GROUP BY sp.id;

-- ----------------------------
-- View structure for p4_df
-- ----------------------------
DROP VIEW IF EXISTS "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."p4_df";
CREATE VIEW "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."p4_df" AS SELECT p4,
count(DISTINCT id) AS df
FROM "theory$prefix4_head_tail_df$ab12cd34ef56$v0".street_p4
GROUP BY p4;

-- ----------------------------
-- View structure for street_norm
-- ----------------------------
DROP VIEW IF EXISTS "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."street_norm";
CREATE VIEW "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."street_norm" AS SELECT id,
regexp_replace(lower(TRIM(BOTH FROM regexp_replace(name::text, '[-\.,/]+'::text, ' '::text, 'g'::
text))), '[[:space:]]+'::text, ' '::text, 'g'::text) AS norm_name
FROM app.street s
WHERE name IS NOT NULL AND name::text <> ''::text;

-- ----------------------------
-- View structure for p4_head_df
-- ----------------------------
DROP VIEW IF EXISTS "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."p4_head_df";
CREATE VIEW "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."p4_head_df" AS SELECT p4,
count(DISTINCT id) AS df_head
FROM "theory$prefix4_head_tail_df$ab12cd34ef56$v0".street_p4
WHERE pos = 1
GROUP BY p4;

-- ----------------------------
-- View structure for street_head_df
-- ----------------------------
DROP VIEW IF EXISTS "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."street_head_df";
CREATE VIEW "theory$prefix4_head_tail_df$ab12cd34ef56$v0"."street_head_df" AS SELECT sp.id,
sp.p4 AS p4_head,
hd.df_head
FROM "theory$prefix4_head_tail_df$ab12cd34ef56$v0".street_p4 sp
JOIN "theory$prefix4_head_tail_df$ab12cd34ef56$v0".p4_head_df hd ON hd.p4 = sp.p4
WHERE sp.pos = 1;
